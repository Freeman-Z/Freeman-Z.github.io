<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ApplicationContext启动过程</title>
    <url>/2021/07/04/ApplicationContext%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="如何理解refresh-？"><a href="#如何理解refresh-？" class="headerlink" title="如何理解refresh()？"></a>如何理解refresh()？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Load or refresh the persistent representation of the configuration,</span></span><br><span class="line"><span class="comment">   * which might an XML file, properties file, or relational database schema.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;As this is a startup method, it should destroy already created singletons</span></span><br><span class="line"><span class="comment">   * if it fails, to avoid dangling resources. In other words, after invocation</span></span><br><span class="line"><span class="comment">   * of that method, either all or no singletons at all should be instantiated.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> BeansException if the bean factory could not be initialized</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalStateException if already initialized and multiple refresh</span></span><br><span class="line"><span class="comment">   * attempts are not supported</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure>
<p>这是ConfigurableApplicationContext接口上refresh()方法的注释，意思是：加载或刷新持久化的配置，可能是XML文件、属性文件或关系数据库中存储的。由于这是一个启动方法，如果失败，它应该销毁已经创建的单例，以避免暂用资源。换句话说，在调用该方法之后，应该实例化所有的单例，或者根本不实例化单例 。</p>
<a id="more"></a>

<p>有个理念需要注意：<strong>ApplicationContext关闭之后不代表JVM也关闭了，ApplicationContext是属于JVM的，说白了ApplicationContext也是JVM中的一个对象。</strong></p>
<p>在Spring的设计中，也提供可以刷新的ApplicationContext和不可以刷新的ApplicationContext。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractRefreshableApplicationContext extends AbstractApplicationContext</span><br></pre></td></tr></table></figure>
<p>就是可以刷新的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GenericApplicationContext extends AbstractApplicationContext</span><br></pre></td></tr></table></figure>
<p>就是不可以刷新的。</p>
<p>AnnotationConfigApplicationContext继承的是GenericApplicationContext，所以它是不能刷新的。</p>
<p>AnnotationConfigWebApplicationContext继承的是AbstractRefreshableWebApplicationContext，所以它是可以刷的。</p>
<p>上面说的<strong>不能刷新是指不能重复刷新，只能调用一次refresh方法，第二次时会报错。</strong></p>
<h2 id="refresh做了哪些事情？"><a href="#refresh做了哪些事情？" class="headerlink" title="refresh做了哪些事情？"></a>refresh做了哪些事情？</h2><p><img src="/2021/07/04/ApplicationContext%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/AnnotationConfigApplicationContext.jpg" alt="AnnotationConfigApplicationContext"></p>
<p>下面以AnnotationConfigApplicationContext为例子，来介绍refresh的底层原理。</p>
<ol>
<li><p>在调用AnnotationConfigApplicationContext的构造方法之前，会调用父类GenericApplicationContext的无参构造方法，会构造一个BeanFactory，为<strong>DefaultListableBeanFactory</strong>。</p>
</li>
<li><p>构造AnnotatedBeanDefinitionReader（<strong>主要作用添加一些基础的PostProcessor，同时可以通过reader进行BeanDefinition的注册</strong>），同时对BeanFactory进行设置和添加<strong>PostProcessor</strong>（后置处理器）</p>
<ol>
<li>设置dependencyComparator：AnnotationAwareOrderComparator，它是一个Comparator，是用来进行排序的，会获取某个对象上的<strong>Order注解</strong>或者通过实现<strong>Ordered接口</strong>所定义的值进行排序，在日常开发中可以利用这个类来进行排序。</li>
<li>设置autowireCandidateResolver：ContextAnnotationAutowireCandidateResolver，用来解析某个Bean能不能进行自动注入，比如某个Bean的autowireCandidate属性是否等于true</li>
<li>向BeanFactory中添加<strong>ConfigurationClassPostProcessor</strong>对应的BeanDefinition，它是一个BeanDefinitionRegistryPostProcessor，并且实现了PriorityOrdered接口</li>
<li>向BeanFactory中添加<strong>AutowiredAnnotationBeanPostProcessor</strong>对应的BeanDefinition，它是一个InstantiationAwareBeanPostProcessorAdapter，MergedBeanDefinitionPostProcessor</li>
<li>向BeanFactory中添加<strong>CommonAnnotationBeanPostProcessor</strong>对应的BeanDefinition，它是一个InstantiationAwareBeanPostProcessor，InitDestroyAnnotationBeanPostProcessor</li>
<li>向BeanFactory中添加EventListenerMethodProcessor对应的BeanDefinition，它是一个BeanFactoryPostProcessor，SmartInitializingSingleton</li>
<li>向BeanFactory中添加DefaultEventListenerFactory对应的BeanDefinition，它是一个EventListenerFactory</li>
</ol>
</li>
<li><p>构造ClassPathBeanDefinitionScanner（<strong>主要作用可以用来扫描得到并注册BeanDefinition</strong>），同时进行设置： </p>
<ol>
<li>设置<strong>this.includeFilters = AnnotationTypeFilter(**</strong>Component**<strong>.class)</strong></li>
<li>设置environment</li>
<li>设置resourceLoader</li>
</ol>
</li>
<li><p> 利用reader注册AppConfig为BeanDefinition，类型为AnnotatedGenericBeanDefinition</p>
</li>
<li><p><strong>接下来就是调用refresh方法</strong></p>
</li>
<li><p>prepareRefresh()：</p>
<ol>
<li>记录启动时间</li>
<li>可以允许子容器设置一些内容到Environment中</li>
<li>验证Environment中是否包括了必须要有的属性</li>
</ol>
</li>
<li><p>obtainFreshBeanFactory()：进行BeanFactory的refresh，在这里会去调用子类的refreshBeanFactory方法，具体子类是怎么刷新的得看子类，然后再调用子类的getBeanFactory方法，重新得到一个BeanFactory</p>
</li>
<li><p>prepareBeanFactory(beanFactory)：</p>
<ol>
<li><p>设置beanFactory的类加载器</p>
</li>
<li><p>设置表达式解析器：StandardBeanExpressionResolver，用来解析Spring中的表达式</p>
</li>
<li><p>添加PropertyEditorRegistrar：ResourceEditorRegistrar，PropertyEditor类型转化器注册器，用来注册一些默认的PropertyEditor</p>
</li>
<li><p>添加一个Bean的后置处理器：ApplicationContextAwareProcessor，是一个BeanPostProcessor，用来执行EnvironmentAware、ApplicationEventPublisherAware等回调方法</p>
</li>
<li><p>添加<strong>ignoredDependencyInterface</strong>：可以向这个属性中添加一些接口，如果某个类实现了这个接口，并且这个类中的某些set方法在接口中也存在，那么这个set方法在自动注入的时候是不会执行的，比如EnvironmentAware这个接口，如果某个类实现了这个接口，那么就必须实现它的setEnvironment方法，而这是一个set方法，和Spring中的autowire是冲突的，那么Spring在自动注入时是不会调用setEnvironment方法的，而是等到回调Aware接口时再来调用（注意，这个功能仅限于xml的autowire，@Autowired注解是忽略这个属性的）</p>
<ol>
<li><p>EnvironmentAware</p>
</li>
<li><p>EmbeddedValueResolverAware</p>
</li>
<li><p>ResourceLoaderAware</p>
</li>
<li><p>ApplicationEventPublisherAware</p>
</li>
<li><p>MessageSourceAware</p>
</li>
<li><p>ApplicationContextAware</p>
<p>另外其实在构造BeanFactory的时候就已经提前添加了另外三个：</p>
</li>
<li><p>BeanNameAware</p>
</li>
<li><p>BeanClassLoaderAware</p>
</li>
<li><p>BeanFactoryAware</p>
</li>
</ol>
</li>
<li><p>添加<strong>resolvableDependencies</strong>：在byType进行依赖注入时，会先从这个属性中根据类型找bean</p>
<ol>
<li>BeanFactory.class：当前BeanFactory对象</li>
<li>ResourceLoader.class：当前ApplicationContext对象</li>
<li>ApplicationEventPublisher.class：当前ApplicationContext对象</li>
<li>ApplicationContext.class：当前ApplicationContext对象</li>
</ol>
</li>
<li><p>添加一个Bean的后置处理器：ApplicationListenerDetector，是一个BeanPostProcessor，用来判断某个Bean是不是ApplicationListener，如果是则把这个Bean添加到ApplicationContext中去，注意一个ApplicationListener只能是单例的</p>
</li>
<li><p>添加一个Bean的后置处理器：LoadTimeWeaverAwareProcessor，是一个BeanPostProcessor，用来判断某个Bean是不是实现了LoadTimeWeaverAware接口，如果实现了则把ApplicationContext中的loadTimeWeaver回调setLoadTimeWeaver方法设置给该Bean。</p>
</li>
<li><p>添加一些单例bean到单例池：</p>
<ol>
<li>“environment”：Environment对象</li>
<li>“systemProperties”：System.getProperties()返回的Map对象</li>
<li>“systemEnvironment”：System.getenv()返回的Map对象</li>
</ol>
</li>
</ol>
</li>
<li><p>postProcessBeanFactory(beanFactory) ： 提供给AbstractApplicationContext的子类进行扩展，具体的子类，可以继续向BeanFactory中再添加一些东西</p>
</li>
<li><p>invokeBeanFactoryPostProcessors(beanFactory)：<strong>执行BeanFactoryPostProcessor</strong></p>
<ol>
<li>此时在BeanFactory中会存在一个BeanFactoryPostProcessor：<strong>ConfigurationClassPostProcessor</strong>，它也是一个<strong>BeanDefinitionRegistryPostProcessor</strong></li>
<li><strong>第一阶段</strong></li>
<li>从BeanFactory中找到类型为BeanDefinitionRegistryPostProcessor的beanName，也就是<strong>ConfigurationClassPostProcessor</strong>， 然后调用BeanFactory的getBean方法得到实例对象</li>
<li>执行<strong>ConfigurationClassPostProcessor的**</strong>postProcessBeanDefinitionRegistry()<strong>方法:</strong><ol>
<li>解析AppConfig类</li>
<li>扫描得到BeanDefinition并注册</li>
<li>解析@Import，@Bean等注解得到BeanDefinition并注册</li>
<li>详细的看另外的笔记，专门分析了<strong>ConfigurationClassPostProcessor是如何工作的</strong></li>
<li>在这里，我们只需要知道在这一步会去得到BeanDefinition，而这些BeanDefinition中可能存在BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor，所以执行完ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry()方法后，还需要继续执行其他BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
</ol>
</li>
<li>执行其他BeanDefinitionRegistryPostProcessor的**postProcessBeanDefinitionRegistry()**方法<ol>
<li><strong>执行所有BeanDefinitionRegistryPostProcessor的</strong>postProcessBeanFactory()<strong>方法</strong></li>
<li>第二阶段**</li>
<li>从BeanFactory中找到类型为BeanFactoryPostProcessor的beanName，而这些BeanFactoryPostProcessor包括了上面的BeanDefinitionRegistryPostProcessor</li>
<li>执行还没有执行过的BeanFactoryPostProcessor的**postProcessBeanFactory()**方法</li>
</ol>
</li>
</ol>
</li>
<li><p>到此，所有的BeanFactoryPostProcessor的逻辑都执行完了，主要做的事情就是得到BeanDefinition并注册到BeanFactory</p>
</li>
<li><p>registerBeanPostProcessors(beanFactory)：因为上面的步骤完成了扫描，这个过程中程序员可能自己定义了一些BeanPostProcessor，在这一步就会把BeanFactory中所有的BeanPostProcessor找出来并实例化得到一个对象，并添加到BeanFactory中去（属性<strong>beanPostProcessors</strong>），最后再重新添加一个ApplicationListenerDetector对象（之前其实就添加了过，这里是为了把ApplicationListenerDetector移动到最后）</p>
</li>
<li><p>initMessageSource()：如果BeanFactory中存在一个叫做”<strong>messageSource</strong>“的BeanDefinition，那么就会把这个Bean对象创建出来并赋值给ApplicationContext的messageSource属性，让ApplicationContext拥有<strong>国际化</strong>的功能</p>
</li>
<li><p>initApplicationEventMulticaster()：如果BeanFactory中存在一个叫做”<strong>applicationEventMulticaster</strong>“的BeanDefinition，那么就会把这个Bean对象创建出来并赋值给ApplicationContext的applicationEventMulticaster属性，让ApplicationContext拥有<strong>事件发布</strong>的功能</p>
</li>
<li><p>onRefresh()：提供给AbstractApplicationContext的子类进行扩展，没用</p>
</li>
<li><p>registerListeners()：从BeanFactory中获取ApplicationListener类型的beanName，然后添加到ApplicationContext中的事件广播器<strong>applicationEventMulticaster</strong>中去，到这一步因为FactoryBean还没有调用getObject()方法生成Bean对象，所以这里要在根据类型找一下ApplicationListener，记录一下对应的beanName</p>
</li>
<li><p>finishBeanFactoryInitialization(beanFactory)：完成BeanFactory的初始化，主要就是<strong>实例化非懒加载的单例Bean</strong>，单独的笔记去讲。</p>
</li>
<li><p>finishRefresh()：BeanFactory的初始化完后，就到了Spring启动的最后一步了</p>
<ol>
<li>设置ApplicationContext的lifecycleProcessor，默认情况下设置的是DefaultLifecycleProcessor</li>
<li>调用lifecycleProcessor的onRefresh()方法，如果是DefaultLifecycleProcessor，那么会获取所有类型为Lifecycle的Bean对象，然后调用它的start()方法，这就是ApplicationContext的生命周期扩展机制</li>
<li>发布<strong>ContextRefreshedEvent</strong>事件</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>框架源码</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty核心功能与线程模型</title>
    <url>/2021/01/21/Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="Netty初窥"><a href="#Netty初窥" class="headerlink" title="Netty初窥"></a>Netty初窥</h3><p>NIO 的类库和 API 繁杂， 使用麻烦： 需要熟练掌握Selector、 ServerSocketChannel、 SocketChannel、 ByteBuffer等。 </p>
<a id="more"></a>

<p>开发工作量和难度都非常大： 例如客户端面临断线重连、 网络闪断、心跳处理、半包读写、 网络拥塞和异常流的处理等等。</p>
<p>Netty 对 JDK 自带的 NIO 的 API 进行了良好的封装，解决了上述问题。且Netty拥有高性能、 吞吐量更高，延迟更低，减少资源消耗，最小化不必要的内存复制等优点。</p>
<p>Netty框架的目标大概可以理解为让业务代码从网络基础应用编码中分离，让开发可以专注开发业务代码，而不用写一大堆类似NIO的网络处理操作。</p>
<h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><h4 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h4><p>Reactor 是一种设计模式，<a href="https://en.wikipedia.org/wiki/Reactor_pattern">wikipedia</a> 对其定义如下：</p>
<blockquote>
<p>Reactor 是一个或多个输入事件的处理模式，用于处理并发传递给服务处理程序的服务请求。服务处理程序判断传入请求发生的事件，并将它们同步的分派给关联的请求处理程序。</p>
</blockquote>
<p>Reactor 模式按照职责不同，通常可以把线程分为 Reactor 线程、IO 线程和业务线程：</p>
<ul>
<li>Reactor 线程：轮询通知发生IO的通道，并分派合适的 Handler 处理</li>
<li>IO 线程：执行实际的读写操作</li>
<li>业务线程：执行应用程序的业务逻辑</li>
</ul>
<h5 id="单线程版本"><a href="#单线程版本" class="headerlink" title="单线程版本"></a>单线程版本</h5><p>单线程版本其实就是用一个线程完成事件的通知，实际的I/O操作和业务处理</p>
<p><img src="/2021/01/21/Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/basic.png" alt="basic"></p>
<p><strong>缺点</strong></p>
<p>Reactor作用就是要迅速的触发Handler，显然Handler处理的过程会导致Reactor变慢，此时可以将非IO操作从Reactor分离。</p>
<h5 id="多线程版本"><a href="#多线程版本" class="headerlink" title="多线程版本"></a>多线程版本</h5><p>多线程版本将业务处理和 I/O 操作进行分离，Reactor 线程只关注事件分发和实际的 IO 操作，业务处理如协议的编解码都分配给线程池处理。</p>
<p><img src="/2021/01/21/Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/multi-threaded.png" alt="multithreaded"></p>
<p><strong>缺点</strong></p>
<p>可能会出现，业务处理很快，大部分的 Reactor 线程都在处理 IO，导致 CPU 闲置，降低了响应速度。</p>
<h5 id="主从版本"><a href="#主从版本" class="headerlink" title="主从版本"></a>主从版本</h5><p>主从 Reactor 版本设计了一个 <strong>主Reactor</strong> 用于处理连接接收事件，多个 <strong>从Reactor</strong> 处理实际的 I/O，分工合作，匹配 CPU 和 IO 速率。</p>
<p><img src="/2021/01/21/Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/master-slave.png" alt="master-slave"></p>
<h4 id="Netty线程模型-1"><a href="#Netty线程模型-1" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h4><p><img src="/2021/01/21/Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/netty.png" alt="netty"></p>
<p><strong>模型解释</strong></p>
<ol>
<li>Netty抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接收客户端的连接，WorkGroup专门负责网络的读写</li>
<li>BossGroup和WorkGroup都是NioEventLoopGroup</li>
<li>NioEventLoopGroup相当于一个事件循环线程组，这个组中含有多个事件循环线程，每一个事件循环线程是NioEventLoop</li>
<li>每个NioEventLoop都有一个selector，用于监听注册在其上的socketChannel的网络通讯</li>
<li>每个Boss NioEventLoop线程内部循环执行的步骤<ul>
<li>处理accept事件，与client建立连接，生成NioSocketChannel</li>
<li>将NioSocketChannel注册到某个worker NioEventLoop上的selector</li>
<li>处理任务队列的任务，即runAllTask</li>
</ul>
</li>
<li>每个worker NioEventLoop处理NioSocketChannel业务时，会使用pipeline(管道)，管道中维护了很多handler处理器用来处理channel中的数据</li>
</ol>
<h3 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h3><h4 id="【Bootstrap、ServerBootStrap】："><a href="#【Bootstrap、ServerBootStrap】：" class="headerlink" title="【Bootstrap、ServerBootStrap】："></a>【Bootstrap、ServerBootStrap】：</h4><p>Bootstrap意思是引导，一个Netty应用通用由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootStrap是服务端的启动引导类</p>
<h4 id="【Future、ChannelFuture】："><a href="#【Future、ChannelFuture】：" class="headerlink" title="【Future、ChannelFuture】："></a>【Future、ChannelFuture】：</h4><p>正如前面介绍,在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理。</p>
<p>但是可以过一会等他执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFuture，他们可以注册一个监听，当操作执行完成或失败时监听会自动触发注册的监听事件。</p>
<h4 id="【Channel】："><a href="#【Channel】：" class="headerlink" title="【Channel】："></a>【Channel】：</h4><p>Netty网络通信的组件，能够用于执行网络的I/O操作。Channel为用户提供：</p>
<ol>
<li><p>当前网络连接的通道的状态（例如是否打开？是否已连接）</p>
</li>
<li><p>网络连接的参数配置（例如接收缓冲区的大小）</p>
</li>
<li><p>提供异步的网络I/O操作（如建立连接，读写，绑定端口），异步调用意味着任何I/O调用都将立即返回，并且不保证在调用结束时所请求的I/O操作已完成。</p>
</li>
<li><p>调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以在I/O操作成功、失败或者取消时回调通知调用方。</p>
</li>
<li><p>支持关联I/O操作与对应的处理程序</p>
<p>不同协议、不同的阻塞类型的连接都有不同的Chennle类型与之对应。</p>
<p>下面是一些常用的Channel类型：</p>
<blockquote>
<p>NioSocketChannel，异步的客户端 TCP Socket 连接。</p>
<p>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</p>
<p>NioDatagramChannel，异步的 UDP 连接。</p>
<p>NioSctpChannel，异步的客户端 Sctp 连接。</p>
<p>NioSctpServerChannel，异步的 Sctp 服务器端连接。这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</p>
</blockquote>
</li>
</ol>
<h4 id="【Selector】"><a href="#【Selector】" class="headerlink" title="【Selector】:"></a>【Selector】:</h4><p>Netty基于Selector对象实现I/O多路复用，通过Selector一个线程可以监听多个连接的Channel事件。当向一个Selector中注册Channel后，Selector内部的机制就可以自动不断地查询(Select)这些注册的Channel是否有已就绪的I/O事件（例如可读，可写，网络连接完成等），这样程序就可以很简单的使用一个线程高效的管理多个Channel</p>
<h4 id="【NioEventLoop】："><a href="#【NioEventLoop】：" class="headerlink" title="【NioEventLoop】："></a>【NioEventLoop】：</h4><p>NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I/O任务和非I/O任务：</p>
<ul>
<li>I/O任务，即selectionKey中ready的事件，如accept、connect、read、write等，由processsSelectedKeys方法触发。</li>
<li>非I/O任务，添加到taskQueue中的任务，如register(),bind()等任务，有runAllTasks方法触发</li>
</ul>
<h4 id="【NioEventLoopGroup】："><a href="#【NioEventLoopGroup】：" class="headerlink" title="【NioEventLoopGroup】："></a>【NioEventLoopGroup】：</h4><p>NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程（NioEventLoop）负责处理多个Channel上的事件，而一个Channel只对应于一个线程。</p>
<h4 id="【ChannelHandler】："><a href="#【ChannelHandler】：" class="headerlink" title="【ChannelHandler】："></a>【ChannelHandler】：</h4><p>ChannelHandler是一个接口，处理I/O事件或拦截I/O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序。</p>
<p>ChanneHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承他的子类：</p>
<blockquote>
<p>ChannelInboundHandler 用于处理入站 I/O 事件。</p>
<p>ChannelOutboundHandler 用于处理出站 I/O 操作。</p>
</blockquote>
<p>或者使用一下适配器类：</p>
<blockquote>
<p>ChannelInboundHandlerAdapter 用于处理入站 I/O 事件。</p>
<p>ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作。</p>
</blockquote>
<h4 id="【ChannelHandlerContext】："><a href="#【ChannelHandlerContext】：" class="headerlink" title="【ChannelHandlerContext】："></a>【ChannelHandlerContext】：</h4><p>保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象。</p>
<h4 id="【ChannelPipeline】："><a href="#【ChannelPipeline】：" class="headerlink" title="【ChannelPipeline】："></a>【ChannelPipeline】：</h4><p>保存ChannelHandler的List，用于处理或拦截Channel的入站事件和出站操作</p>
<p>ChannelPipeline实现了一种高级形式的拦截过滤器模式，是用户可以完全控制事件的处理方式，以及Channel中各个ChannelHandler如何相互相互。</p>
<p>在Netty中每个Channel都有且仅有一个ChannelPipeline与之对应，他们的组成关系：</p>
<p><img src="/2021/01/21/Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/channel_pipeline.png" alt="channel_pipeline"></p>
<p>一个Channel包含了一个ChannelPipeline，而ChannelPipeline中又维护一个由ChaennlHandlerContext组成的双向链表，并且每个ChannelHandlerContext中有关联着一个ChannelHandler。</p>
<p>read事件(入站事件)和write事件(出站事件)在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会从链表tail往前传递到最前一个出战的handler，两种类型的handler互不干扰</p>
<h3 id="ByteBuf详解"><a href="#ByteBuf详解" class="headerlink" title="ByteBuf详解"></a>ByteBuf详解</h3><p>从结构上来说，ByteBuf有一串字节数组构成。数组中每个字节用来存放信息。</p>
<p>ByteBuf提供了两个索引，一个用于读取数据，一个用于写入数据。这两个索引通过在字节数组中移动，来定位需要读或者写信息的位置</p>
<p>当从ByteBuf读取时，它的readIndex(读索引)将会根据读取的字节递增。</p>
<p>同样当写ByteBuf时，他的writeIndex也会根据写入的字节数进行递增。</p>
<p><img src="/2021/01/21/Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/byte-buf.png" alt="ByteBuf"></p>
<p>需要注意的是极限的情况是 readerIndex 刚好读到了 writerIndex 写入的地方。<br>如果 readerIndex 超过了 writerIndex 的时候，Netty 会抛出 IndexOutOf-BoundsException 异常。</p>
<blockquote>
<p>已经读取的区域：[0,readerindex)</p>
<p>可读取的区域：[readerindex,writerIndex)</p>
<p> 可写的区域: [writerIndex,capacity)</p>
</blockquote>
]]></content>
      <categories>
        <category>分布式框架</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty核心源码解析</title>
    <url>/2021/02/13/Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Netty高并发高性能架构设计精髓"><a href="#Netty高并发高性能架构设计精髓" class="headerlink" title="Netty高并发高性能架构设计精髓"></a>Netty高并发高性能架构设计精髓</h3><ul>
<li><p>主从Reactor模型</p>
</li>
<li><p>NIO多路复用非阻塞</p>
</li>
<li><p>无锁串行化思想</p>
</li>
<li><p>支持高性能序列化协议</p>
</li>
<li><p>零拷贝（直接内存的使用）</p>
</li>
<li><p>ByteBuf内存池设计</p>
</li>
<li><p>灵活的TCP参数配置能力</p>
</li>
<li><p>并发优化</p>
<a id="more"></a>

</li>
</ul>
<h3 id="Netty线程模型图"><a href="#Netty线程模型图" class="headerlink" title="Netty线程模型图"></a>Netty线程模型图</h3><p><img src="/2021/02/13/Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/netty.png" alt="netty"></p>
<!-- more -->

<h3 id="Netty核心源码流程图"><a href="#Netty核心源码流程图" class="headerlink" title="Netty核心源码流程图"></a>Netty核心源码流程图</h3><p><a href="https://www.processon.com/view/link/6026a96a1e0853211997579d">https://www.processon.com/view/link/6026a96a1e0853211997579d</a></p>
<p><img src="/2021/02/13/Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/server-bootstrap.jpg" alt="server-bootstrap"></p>
]]></content>
      <categories>
        <category>分布式框架</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty编解码&amp;粘包拆包&amp;心跳机制&amp;断线自动重连</title>
    <url>/2021/01/25/Netty%E7%BC%96%E8%A7%A3%E7%A0%81-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6-%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/</url>
    <content><![CDATA[<h3 id="Netty编解码"><a href="#Netty编解码" class="headerlink" title="Netty编解码"></a>Netty编解码</h3><p>Netty涉及到编解码的组件有Channel、ChannelHandler、ChannelPipe等</p>
<a id="more"></a>

<p><strong>ChannelHandler</strong></p>
<p>ChannelHandler充当了处理入站和出站数据的应用程序逻辑容器。例如，实现ChannelInboundHandler接口(或ChannelInboundHandlerAdapter)，你就可以接收入站事件和数据，这些数据随后会被你的应用程序的业务逻辑处理。当你要给连接的客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。你的业务逻辑通常写在一个或者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不过它是用来处理出站数据的。</p>
<p><strong>ChannelPipeline</strong></p>
<p>ChannelPipeline提供了ChannelHandler链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler(ChannelOutboundHandler调用是从tail到head方向逐个调用每个handler的逻辑)，并被这些Handler处理，反之则称为入站的，入站只调用pipeline里的ChannelInboundHandler逻辑(ChannelInboundHandler调用是从head到tail方向逐个调用每个handler的逻辑)。</p>
<p><img src="/2021/01/25/Netty%E7%BC%96%E8%A7%A3%E7%A0%81-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6-%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/channel-pipeline.png" alt="channel_pipeline"></p>
<h4 id="编码解码器"><a href="#编码解码器" class="headerlink" title="编码解码器"></a>编码解码器</h4><p>当你通过Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如java对象）；如果是出站消息，它会被编码成字节。<br>Netty提供了一系列实用的编码解码器，他们都实现了ChannelInboundHadnler或者ChannelOutboundHandler接口。在这些类中，channelRead方法已经被重写了。以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，它将调用由已知解码器所提供的decode()方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler。<br>Netty提供了很多编解码器，比如编解码字符串的StringEncoder和StringDecoder，编解码对象的ObjectEncoder和ObjectDecoder等。<br>如果要实现高效的编解码可以用protobuf，但是protobuf需要维护大量的proto文件比较麻烦，现在一般可以使用protostuff。<br>protostuff是一个基于protobuf实现的序列化方法，它较于protobuf最明显的好处是，在几乎不损耗性能的情况下做到了不用我们写.proto文件来实现序列化。使用它也非常简单</p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h3><p>TCP是一个流协议，就是没有界限的一长串二进制数据。TCP作为传输层协议并不不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。面向流的通信是无消息保护边界的。<br>如下图所示，client发了两个数据包D1和D2，但是server端可能会收到如下几种情况的数据。</p>
<p><img src="/2021/01/25/Netty%E7%BC%96%E8%A7%A3%E7%A0%81-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6-%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/tcp.png" alt="tcp"></p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>消息定长度，传输的数据大小固定长度，例如每段的长度固定为100字节，如果不够空位补空格</p>
</li>
<li><p>在数据包尾部添加特殊分隔符，比如下划线，中划线等，这种方法简单易行，但选择分隔符的时候一定要注意每条数据的内部一定不能出现分隔符</p>
</li>
<li><p>发送长度：在发送每条数据的时候，将数据的长度一并发送，比如可以选择每天数据的前4位是数据的长度，应用层处理是可以根据长度来判断每条数据的开始和结束</p>
<p>Netty提供了多个解码器，可以进行分包操作，如：</p>
<ul>
<li>LineBasedFrameDecoder （回车换行分包）</li>
<li>DelimiterBasedFrameDecoder（特殊分隔符分包）</li>
<li>FixedLengthFrameDecoder（固定长度报文来分包）</li>
</ul>
</li>
</ol>
<h3 id="Netty心跳检测机制"><a href="#Netty心跳检测机制" class="headerlink" title="Netty心跳检测机制"></a>Netty心跳检测机制</h3><p>所谓心跳, 即在 TCP 长连接中, 客户端和服务器之间定期发送的一种特殊的数据包, 通知对方自己还在线, 以确保 TCP 连接的有效性.<br>在 Netty 中, 实现心跳机制的关键是 IdleStateHandler, 看下它的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> readerIdleTimeSeconds,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> writerIdleTimeSeconds,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> allIdleTimeSeconds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>(readerIdleTimeSeconds, writerIdleTimeSeconds, allIdleTimeSeconds,</span><br><span class="line">         TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数含义：</p>
<ul>
<li><p>readerIdleTimeSeconds：读超时，即当在指定的时间间隔内没有从 Channel 读取到数据时, 会触发一个 READER_IDLE 的 IdleStateEvent 事件.</p>
</li>
<li><p>writerIdleTimeSeconds: 写超时. 即当在指定的时间间隔内没有数据写入到 Channel 时, 会触发一个 WRITER_IDLE 的 IdleStateEvent 事件.</p>
</li>
<li><p>allIdleTimeSeconds: 读/写超时. 即当在指定的时间间隔内没有读或写操作时, 会触发一个 ALL_IDLE 的 IdleStateEvent 事件.</p>
<p>注：这三个参数默认的时间单位是秒。若需要指定其他时间单位，可以使用另一个构造方法：<br>IdleStateHandler(boolean observeOutput, long readerIdleTime, long writerIdleTime, long allIdleTime, TimeUnit unit)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现Netty服务端心跳检测机制需要在服务器端的ChannelInitializer中加入如下的代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>初步地看下IdleStateHandler源码，先看下IdleStateHandler中的channelRead方法：</p>
<p><img src="/2021/01/25/Netty%E7%BC%96%E8%A7%A3%E7%A0%81-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6-%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/channel-read.png" alt="channelRead"></p>
<p>该方法只是进行了透传，不做任何业务逻辑处理，让channelPipe中的下一个handler处理channelRead方法</p>
<p>再看一下channelActive方法：</p>
<p><img src="/2021/01/25/Netty%E7%BC%96%E8%A7%A3%E7%A0%81-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6-%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/channel-read-complete.png" alt="channelReadComplete"></p>
<p>该方法将上次读取时间设置成了当前时间</p>
<p>再看看channelActive方法：</p>
<p><img src="/2021/01/25/Netty%E7%BC%96%E8%A7%A3%E7%A0%81-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6-%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/channel-active.png" alt="channelActive"></p>
<p>这里有个initialize的方法，这是IdleStateHandler的精髓，接着探究：</p>
<p><img src="/2021/01/25/Netty%E7%BC%96%E8%A7%A3%E7%A0%81-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6-%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/initialize.png" alt="initialize"></p>
<p>这边会触发一个Task，ReaderIdleTimeoutTask，这个task里的run方法源码是这样的：</p>
<p><img src="/2021/01/25/Netty%E7%BC%96%E8%A7%A3%E7%A0%81-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6-%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/read-timeout-task.png" alt="readTimeoutTask"></p>
<p>第一个红框的代码表示：nextDelay = 当前时间-上次读取时间(channelReadComplete设置)-读超时时间，表示现在距离读超时还剩多长的时间。</p>
<ul>
<li><p>如果这个值大于0，会触发第四个红框，触发一个新的Task，时间是剩余的超时时长（下次再继续检查）。</p>
</li>
<li><p>如果这个值小于0，会重新触发一个设置超时时长的Task，然后会触发下一个handler的userEventTriggered方法：</p>
<p><img src="/2021/01/25/Netty%E7%BC%96%E8%A7%A3%E7%A0%81-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6-%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/channel-idle.png" alt="channelIdle"></p>
</li>
</ul>
<h3 id="Netty断线自动重连实现"><a href="#Netty断线自动重连实现" class="headerlink" title="Netty断线自动重连实现"></a>Netty断线自动重连实现</h3><ol>
<li>客户端启动连接服务端时，如果网络或服务端有问题，客户端连接失败，可以重连，重连的逻辑加在客户端。</li>
</ol>
<ol start="2">
<li>系统运行过程中网络故障或服务端故障，导致客户端与服务端断开连接了也需要重连，可以在客户端处理数据的Handler的channelInactive方法中进行重连。</li>
</ol>
]]></content>
      <categories>
        <category>分布式框架</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中Bean的生命周期</title>
    <url>/2021/05/30/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>Spring最重要的功能就是帮助程序员创建对象（也就是IOC），而启动Spring就是为创建Bean对象做准备，所以我们先明白Spring到底是则呢怎么去创建Bean的，也就是先弄明白Bean的生命周期。</p>
<p>Bean的生命周期就是指：<strong>在Spring中，一个Bean是如何生成的，如何销毁的？</strong></p>
<a id="more"></a>

<p><img src="/2021/05/30/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.jpg" alt="Bean的生命周期"></p>
<h2 id="Bean的生成过程"><a href="#Bean的生成过程" class="headerlink" title="Bean的生成过程"></a>Bean的生成过程</h2><h3 id="1-生成BeanDefinition"><a href="#1-生成BeanDefinition" class="headerlink" title="1.生成BeanDefinition"></a>1.生成BeanDefinition</h3><p>Spring启动的时候会进行扫描，会先调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br></pre></td></tr></table></figure>
<p>拿到所指定的包路径下的所有文件资源（******.class文件）</p>
<p>然后会遍历每个Resource，为每个Resource生成一个MetadataReader对象，这个对象拥有三个功能：</p>
<ol>
<li>获取对应的Resource资源</li>
<li>获取Resource对应的class元数据信息，包括类的名字，是不是接口、是不是一个注解、是不是抽象类、有没有父类，父类的名字，所实现的所有接口的名字，内部类的类名等等</li>
<li>获取Resource对应的class上的注解信息，当前类上有哪些注解，当前类中有哪些方法上有注解</li>
</ol>
<p>在生成MetadataReader对象时，会利用<strong>ASM</strong>技术解析class文件，得到类的元数据集信息合注解信息，在这个过程中也会利用ClassLoader去加载注解类（<strong>ClassUtils.getDefaultClassLoader()所获得的类加载器</strong>），但是不会加载本类。</p>
<p>有了MetadataReader对象，就相当于有了当前类的所有信息，但是当前类并没有加载，也是可以理解的，真正在用到这个类的时候才加载。</p>
<p>然后利用MetadataReader对象生成一个ScannedGenericBeanDefinition对象，<strong>注意此时的BeanDefinition对象中的beanClass属性存储的是当前类的名字，而不是class对象</strong>。（beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象）</p>
<h3 id="2-合并BeanDefinition"><a href="#2-合并BeanDefinition" class="headerlink" title="2.合并BeanDefinition"></a>2.合并BeanDefinition</h3><p>如果某个BeanDefinition存在父BeanDefinition，那么则要进行合并，递归到往上找到父类，用父类的BeanDefinition新建一个RootBeanDefinition，再用子类的属性覆盖父类的属性。（ 在这个过程中，父类和子类存放在beanDefinitionMap当中的BeanDefinition其实是没有改变的，而是新生成了一个RootBeanDefinition存放在了mergedBeanDefinitions这个map里）</p>
<h3 id="3-加载类"><a href="#3-加载类" class="headerlink" title="3. 加载类"></a>3. 加载类</h3><p>有了BeanDefinition之后，后续就会基于BeanDefinition去创建Bean，而创建Bean就必须实例化对象，而实例化就必须先加载当前BeanDefinition所对应的class，在AbstractAutowireCapableBeanFactory类的createBean()方法中，一开始就会调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br></pre></td></tr></table></figure>


<p>这行代码就是去加载类，该方法是这么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class="line">    <span class="keyword">return</span> mbd.getBeanClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;) () -&gt;</span><br><span class="line">        doResolveBeanClass(mbd, typesToMatch), getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean hasBeanClass() &#123;</span><br><span class="line">    return (this.beanClass instanceof Class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果beanClass属性的类型是Class，那么就直接返回，如果不是，则会根据类名进行加载（doResolveBeanClass方法所做的事情）</p>
<p>会利用BeanFactory所设置的类加载器来加载类，如果没有设置，则默认使用**ClassUtils.getDefaultClassLoader()**所返回的类加载器来加载。</p>
<h4 id="ClassUtils-getDefaultClassLoader"><a href="#ClassUtils-getDefaultClassLoader" class="headerlink" title="ClassUtils.getDefaultClassLoader()"></a><strong>ClassUtils.getDefaultClassLoader()</strong></h4><ol>
<li>优先获取当前线程中的ClassLoader</li>
<li>如果为空，则获取加载ClassUtils类的类加载器（正常情况下，就是AppClassLoader，但是如果是在Tomcat中运行，那么则会是Tomcat中为每个应用所创建的WebappClassLoader）</li>
<li>如果为空，那么则是bootstrap类加载器加载的ClassUtils类，那则获取系统类加载器进行加载</li>
</ol>
<h3 id="4-实例化前"><a href="#4-实例化前" class="headerlink" title="4. 实例化前"></a>4. 实例化前</h3><p>允许第三方可以不按照Spring的正常流程来创建一个Bean。</p>
<p>可以利用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法来提前返回一个Bean对象，得到对象后会直接</p>
<p>跳到进行<strong>Bean初始化</strong>的方法，然后直接结束Bean的生命周期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">         InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">         Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">         <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="5-推断构造方法"><a href="#5-推断构造方法" class="headerlink" title="5. 推断构造方法"></a>5. 推断构造方法</h3><p>选择一个合适的构造器用来创建实例对象</p>
<h3 id="6-实例化"><a href="#6-实例化" class="headerlink" title="6. 实例化"></a>6. 实例化</h3><p>构造方法反射得到一个实例</p>
<h3 id="7-BeanDefinition的后置处理"><a href="#7-BeanDefinition的后置处理" class="headerlink" title="7. BeanDefinition的后置处理"></a>7. BeanDefinition的后置处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">        MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">        bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以处理BeanDefinition，但是此时实例对象已经生成好了，所以修改beanClass已经没用了，但是可以修改PropertyValues，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LubanMergedBeanDefinitionPostProcessor</span> <span class="keyword">implements</span> <span class="title">MergedBeanDefinitionPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;userService&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//实例对象已经生成，此时变更没有意义</span></span><br><span class="line">            beanDefinition.setBeanClass(User.class); </span><br><span class="line">            beanDefinition.getPropertyValues().add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-实例化后（填充属性前）"><a href="#8-实例化后（填充属性前）" class="headerlink" title="8. 实例化后（填充属性前）"></a>8. 实例化后（填充属性前）</h3><p>可以自己写一个InstantiationAwareBeanPostProcessor，然后重写postProcessAfterInstantiation方法返回false,那么则不会进行属性填充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">      InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">      <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-填充属性"><a href="#9-填充属性" class="headerlink" title="9. 填充属性"></a>9. 填充属性</h3><p>使用Spring自带的Autowired，默认是关闭的(AUTOWIRE_NO)</p>
<p>其实就是Spring自动的根据某个类中的set方法来找bean</p>
<ul>
<li>byName就是根据某个set方法所对应的属性名去找bean</li>
<li>byType，就是根据某个set方法的参数类型去找bean</li>
</ul>
<h3 id="10-填充属性后"><a href="#10-填充属性后" class="headerlink" title="10. 填充属性后"></a>10. 填充属性后</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">      InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用BeanPostProcessor分别解析@Autowired、@Resource、@Value，得到属性值</span></span><br><span class="line">      PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">         &#125;</span><br><span class="line">         pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">         <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = pvsToUse;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@Autowired注解的 AutowiredAnnotationBeanPostProcessor</p>
<p>@Resource注解的 CommonAnnotationBeanPostProcessor</p>
</blockquote>
<h3 id="11-执行Aware"><a href="#11-执行Aware" class="headerlink" title="11. 执行Aware"></a>11. 执行Aware</h3><ol>
<li>((BeanNameAware) bean).setBeanName(beanName);</li>
<li>((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</li>
<li>((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<strong>this</strong>);</li>
</ol>
<h3 id="12-初始化前"><a href="#12-初始化前" class="headerlink" title="12. 初始化前"></a>12. 初始化前</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">    Object current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="13-初始化"><a href="#13-初始化" class="headerlink" title="13. 初始化"></a>13. 初始化</h3><ol>
<li>((InitializingBean) bean).afterPropertiesSet();</li>
<li>执行BeanDefinition中指定的初始化方法</li>
</ol>
<h3 id="14-初始化后"><a href="#14-初始化后" class="headerlink" title="14. 初始化后"></a>14. 初始化后</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">    Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Bean的销毁过程"><a href="#Bean的销毁过程" class="headerlink" title="Bean的销毁过程"></a>Bean的销毁过程</h2><h3 id="1-容器关闭"><a href="#1-容器关闭" class="headerlink" title="1. 容器关闭"></a>1. 容器关闭</h3><h3 id="2-发布ContextClosedEvent事件"><a href="#2-发布ContextClosedEvent事件" class="headerlink" title="2. 发布ContextClosedEvent事件"></a>2. 发布ContextClosedEvent事件</h3><h3 id="3-调用LifecycleProcessor的onClose方法"><a href="#3-调用LifecycleProcessor的onClose方法" class="headerlink" title="3. 调用LifecycleProcessor的onClose方法"></a>3. 调用LifecycleProcessor的onClose方法</h3><h3 id="4-销毁单例Bean"><a href="#4-销毁单例Bean" class="headerlink" title="4. 销毁单例Bean"></a>4. 销毁单例Bean</h3><ol>
<li>找出所有DisposableBean(实现了DisposableBean接口的Bean)</li>
<li>遍历每个DisposableBean</li>
<li>找出依赖了当前DisposableBean的其他Bean，将这些Bean从单例池中移除掉</li>
<li>调用DisposableBean的destroy()方法</li>
<li>找到当前DisposableBean所包含的inner beans，将这些Bean从单例池中移除掉 </li>
</ol>
<p>这里涉及到一个设计模式：<strong>适配器模式</strong></p>
<p>在销毁时，Spring会找出实现了DisposableBean接口的Bean。</p>
<p>但是我们在定义一个Bean时，如果这个Bean实现了DisposableBean接口，或者实现了AutoCloseable接口，或者在BeanDefinition中指定了destroyMethodName，那么这个Bean都属于“DisposableBean”，这些Bean在容器关闭时都要调用相应的销毁方法。</p>
<p>所以，这里就需要进行适配，将实现了DisposableBean接口、或者AutoCloseable接口等适配成实现了DisposableBean接口，所以就用到了DisposableBeanAdapter，会把实现了AutoCloseable接口的类封装成DisposableBeanAdapter，而DisposableBeanAdapter实现了DisposableBean接口。</p>
]]></content>
      <categories>
        <category>框架源码</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring依赖注入流程</title>
    <url>/2021/06/09/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>Spring有几种依赖注入的方式</strong></p>
<p>首先分两种：</p>
<ol>
<li>手动注入</li>
<li>自动注入</li>
</ol>
<a id="more"></a>

<h2 id="手动注入"><a href="#手动注入" class="headerlink" title="手动注入"></a>手动注入</h2><p>在XML中定义Bean时，就是手动注入，因为是<strong>程序员**</strong>手动**<strong>给某个属性指定了值</strong>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.demo.service.UserService&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;orderService&quot;</span> ref=<span class="string">&quot;orderService&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上面这种底层是通过<strong>set方法</strong>进行注入。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.demo.service.UserService&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg index=<span class="string">&quot;0&quot;</span> ref=<span class="string">&quot;orderService&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上面这种底层是通过<strong>构造方法</strong>进行注入。</p>
<p>所以手动注入的底层也就是分为两种：</p>
<ol>
<li>set方法</li>
<li>构造方法</li>
</ol>
<h2 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h2><p>自动注入又分为两种：</p>
<ol>
<li>XML的autowire自动注入</li>
<li>@Autowired注解的自动注入</li>
</ol>
<h3 id="XML的autowire自动注入"><a href="#XML的autowire自动注入" class="headerlink" title="XML的autowire自动注入"></a>XML的autowire自动注入</h3><p>在XML中，我们可以在定义一个Bean时去指定这个Bean的自动注入模式：</p>
<ol>
<li>byType</li>
<li>byName</li>
<li>constructor</li>
<li>default</li>
<li>no</li>
</ol>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.luban.service.UserService&quot;</span> autowire=<span class="string">&quot;byType&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>这么写，表示Spring会自动的给userService中所有的属性自动赋值（<strong>不需要</strong>这个属性上有@Autowired注解，但需要这个属性有对应的<strong>set方法</strong>）。</p>
<p>在创建Bean的过程中，在填充属性时，Spring会去解析当前类，把当前类的所有方法都解析出来，Spring会去解析每个方法得到对应的PropertyDescriptor对象（注意PropertyDescriptor并不是Spring中的类，而是java.beans包下类，也就是jdk自带的类），PropertyDescriptor中有几个属性：</p>
<ol>
<li><p><strong>name：这个name并不是方法的名字，而是拿方法名字进过处理后的名字</strong></p>
<ol>
<li><p><strong>如果方法名字以“get”开头，比如“getXXX”,那么name=XXX</strong></p>
</li>
<li><p><strong>如果方法名字以“is”开头，比如“isXXX”,那么name=XXX</strong></p>
</li>
<li><p><strong>如果方法名字以“set”开头，比如“setXXX”,那么name=XXX</strong></p>
</li>
</ol>
</li>
<li><p><strong>readMethodRef：表示get方法的Method对象的引用</strong></p>
</li>
<li><p><strong>readMethodName：表示get方法的名字</strong></p>
</li>
<li><p><strong>writeMethodRef：表示set方法的Method对象的引用</strong></p>
</li>
<li><p><strong>writeMethodName：表示set方法的名字</strong></p>
</li>
<li><p><strong>propertyTypeRef：如果有get方法那么对应的就是返回值的类型，如果是set方法那么对应的就是set方法中唯一参数的类型</strong></p>
</li>
</ol>
<p>get方法的定义是： 方法参数个数为0个，并且 （方法名字以”get”开头 或者 方法名字以”is”开头并且方法的返回类型为boolean）</p>
<p>set方法的定义是：方法参数个数为1个，并且 （方法名字以”set”开头并且方法返回类型为void）</p>
<h4 id="byName的自动填充属性时流程是："><a href="#byName的自动填充属性时流程是：" class="headerlink" title="byName的自动填充属性时流程是："></a>byName的自动填充属性时流程是：</h4><ol>
<li><strong>找到所有set方法所对应的XXX部分的名字</strong></li>
<li><strong>根据XXX部分的名字去获取bean</strong></li>
</ol>
<h4 id="byType的自动填充属性时流程是："><a href="#byType的自动填充属性时流程是：" class="headerlink" title="byType的自动填充属性时流程是："></a>byType的自动填充属性时流程是：</h4><ol>
<li><strong>找到所有set方法所对应的XXX部分的名字</strong></li>
<li><strong>根据XXX部分的名字重新再获取得到PropertyDescriptor</strong></li>
<li><strong>获取到set方法中的唯一参数的类型，并且根据该类型去容器中获取bean</strong></li>
<li><strong>如果找到多个，会报错。</strong></li>
</ol>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>当某个bean是通过构造方法来注入时，表示Spring在利用构造方法实例化一个对象时，可以利用构造方法的参数信息从Spring容器中去找bean，找到bean之后作为参数传给构造方法，从而实例化得到一个bean对象。（具体推断构造方法，之后细说）</p>
<h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><p>表示默认值，我们一直演示的<bean>标签的的autowire，而也可以直接在<beans>标签中设置autowire，如果设置了，那么<bean>标签中设置的autowire如果为default，那么则会用<beans>标签中设置的autowire。</beans></bean></beans></bean></p>
<h4 id="no"><a href="#no" class="headerlink" title="no"></a>no</h4><p>表示默认值，我们一直演示的某个bean的autowire，而也可以直接在<beans>标签中设置autowire，如果设置了，那么<bean>标签中设置的autowire如果为default，那么则会用<beans>标签中设置的autowire。</beans></bean></beans></p>
<p><strong>为什么我们平时都是用的@Autowired注解呢？而没有用上文说的这种自动注入方式呢？</strong></p>
<p>Spring官网有提到：从本质上讲，@Autowired注解提供了与autowire相同的功能，但是拥有更细粒度的控制和更广泛的适用性。</p>
<p>如果一个类有多个构造方法，那么如果用XML的autowire=constructor，你无法控制到底用哪个构造方法，而你可以用@Autowired注解来直接指定你想用哪个构造方法。</p>
<p>XML中的autowire控制的是整个bean的所有属性，而@Autowired注解是直接写在某个属性、set方法、构造方法上的，而如果用@Autowired注解，可以控制，哪些属性想被自动注入，哪些属性不想，这也是细粒度的控制。</p>
<p>但是@Autowired无法区分byType和byName，@Autowired是先byType，如果找到多个则再byName。</p>
<p>那么XML的自动注入底层其实也就是:</p>
<ol>
<li>set方法</li>
<li>构造方法</li>
</ol>
<h3 id="Autowired注解的自动注入"><a href="#Autowired注解的自动注入" class="headerlink" title="@Autowired注解的自动注入"></a>@Autowired注解的自动注入</h3><p>@Autowired、@Value、@Inject注解可以写在：</p>
<ol>
<li>属性上：先根据属性类型去找Bean，如果找到多个再根据属性名确定一个</li>
<li>构造方法上：先根据方法参数类型去找Bean，如果找到多个再根据参数名确定一个</li>
<li>普通（非静态）方法上：先根据方法参数类型去找Bean，如果找到多个再根据参数名确定一个</li>
</ol>
<p>而这种底层到了：</p>
<ol>
<li>属性</li>
<li>set方法</li>
<li>构造方法</li>
</ol>
<h4 id="Autowired底层实现原理"><a href="#Autowired底层实现原理" class="headerlink" title="@Autowired底层实现原理"></a>@Autowired底层实现原理</h4><h5 id="找出注入点"><a href="#找出注入点" class="headerlink" title="找出注入点"></a>找出注入点</h5><p>在创建一个Bean的过程中，Spring会利用AutowiredAnnotationBeanPostProcessor的postProcessMergedBeanDefinition()找出注入点，加了@Autowired、@Value、@Inject注解的就是注入点，比如：</p>
<ol>
<li>某个属性（AutowiredFieldElement）</li>
<li>某个方法（先不管构造方法）（AutowiredMethodElement）</li>
</ol>
<p>把这些注入点信息找出来之后会进行缓存中（Set<InjectedElement> ），InjectedElement就表示注入点</InjectedElement></p>
<h5 id="进行注入"><a href="#进行注入" class="headerlink" title="进行注入"></a>进行注入</h5><p>Spring会利用AutowiredAnnotationBeanPostProcessor的postProcessProperties()方法中，会遍历InjectionMetadata中的注入点开始进行注入。</p>
<h4 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h4><img src="/2021/06/09/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B/Autowired注入执行流程.jpg" alt="Autowired注入执行流程">



<h3 id="Resource底层实现原理"><a href="#Resource底层实现原理" class="headerlink" title="@Resource底层实现原理"></a>@Resource底层实现原理</h3><h5 id="找出注入点-1"><a href="#找出注入点-1" class="headerlink" title="找出注入点"></a>找出注入点</h5><p>在创建一个Bean的过程中，Spring会利用CommonAnnotationBeanPostProcessor的postProcessMergedBeanDefinition()找出注入点，加了@Resource注解的就是注入点，比如：</p>
<ol>
<li>某个属性（ResourceElement）</li>
<li>某个方法（先不管构造方法）（ResourceElement）</li>
</ol>
<p>把这些注入点信息找出来之后会进行缓存中（Set<InjectedElement> ），InjectedElement就表示注入点</InjectedElement></p>
<h5 id="进行注入-1"><a href="#进行注入-1" class="headerlink" title="进行注入"></a>进行注入</h5><p>Spring会利用CommonAnnotationBeanPostProcessor的postProcessProperties()方法中，会遍历Set<InjectedElement>中的注入点开始进行注入。</InjectedElement></p>
<p>如果@Resource注解中指定了name属性，那么则只会根据name属性的值去找bean，如果找不到则报错</p>
<p>如果@Resource注解没有指定name属性，那么会先判断当前注入点名字（属性名字或普通方法名字或者set方法后缀）是不是存在Bean，如果存在，则直接根据注入点名字取获取bean，如果不存在，则会走@Autowired注解的逻辑，会根据注入点类型去找Bean</p>
<h4 id="核心流程-1"><a href="#核心流程-1" class="headerlink" title="核心流程"></a>核心流程</h4><p><img src="/2021/06/09/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B/Resource%E6%89%A7%E8%A1%8C%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B.jpg" alt="Resource执行注入流程"></p>
]]></content>
      <categories>
        <category>框架源码</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的核心概念</title>
    <url>/2021/03/22/Spring%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>Bean的定义，BeanDefinition可以理解为底层源码级别的一个概念，也可以理解为Spring提供的一种<strong>API使用</strong>的方式。</p>
<a id="more"></a>

<h2 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h2><h3 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a>AnnotatedBeanDefinitionReader</h3><p>可以直接把某个类转换为BeanDefinition，并且会解析该类上的注解</p>
<p>注意：它能解析的注解是：@Conditional，@Scope、@Lazy、@Primary、@DependsOn、@Role、@Description</p>
<h3 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h3><p>可以解析&lt;bean/&gt;标签</p>
<h3 id="ClassPathBeanDefinitionScanner"><a href="#ClassPathBeanDefinitionScanner" class="headerlink" title="ClassPathBeanDefinitionScanner"></a>ClassPathBeanDefinitionScanner</h3><p>这个并不是BeanDefinitionReader，但是它的作用和BeanDefinitionReader类似，它可以进行扫描，扫描某个包路径，对扫描到的类进行解析，比如，扫描到的类上如果存在@Component注解，那么就会把这个类解析为一个BeanDefinition</p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>Spring中比较核心的是BeanFactory的实现类是<strong>DefaultListableBeanFactory</strong></p>
<p><img src="/2021/03/22/Spring%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/default-listable-bean-factory.png" alt="default-listable-bean-factory"></p>
<p>实现接口也表示他具有以下的功能</p>
<ol>
<li>AliasRegistry：支持别名功能，一个名字可以对应多个别名</li>
<li>BeanDefinitionRegistry：可以支持注册，删除，保存，获取某个BeanDefintion</li>
<li>BeanFactory：Bean工厂，可以根据Bean的名称、类型、别名获的Bean对象</li>
<li>SingletonBeanRegistry：可以注册，获取某个单例Bean</li>
<li>SimpleAliasRegistry：是一个类，实现了AliasRegistry接口中所定义的功能，支持别名功能</li>
<li>ListableBeanFactory：在BeanFactory的基础上，增加了其他功能，可以获取所有BeanDefinition的beanNames，可以根据某个类型获取对应的beanNames，可以根据某个类型获取{类型：对应的Bean}的映射关系</li>
<li>HierarchicalBeanFactory：在BeanFactory的基础上，添加了获取父BeanFactory的功能</li>
<li>DefaultSingletonBeanRegistry：它是一个类，SimpleAliasRegistry的子类，支持别名功能，同时实现了SingletonBeanRegistry接口，拥有了直接注册、获取某个<strong>单例</strong>Bean的功能</li>
<li>ConfigurableBeanFactory：在HierarchicalBeanFactory和SingletonBeanRegistry的基础上，添加了设置父BeanFactory、类加载器（表示可以指定某个类加载器进行类的加载）、设置Spring EL表达式解析器（表示该BeanFactory可以解析EL表达式）、设置类型转化服务（表示该BeanFactory可以进行类型转化）、可以添加BeanPostProcessor（表示该BeanFactory支持Bean的后置处理器），可以合并BeanDefinition，可以销毁某个Bean等等功能</li>
<li>FactoryBeanRegistrySupport：DefaultSingletonBeanRegistry的子类，支持了FactoryBean的功能</li>
<li>AutowireCapableBeanFactory：是直接继承了BeanFactory，在BeanFactory的基础上，支持在创建Bean的过程中能对Bean进行自动装配</li>
<li>AbstractBeanFactory：实现了ConfigurableBeanFactory接口，继承了FactoryBeanRegistrySupport，这个BeanFactory的功能已经很全面了，但是不能自动装配和获取beanNames</li>
<li>ConfigurableListableBeanFactory：继承了ListableBeanFactory、AutowireCapableBeanFactory、ConfigurableBeanFactory</li>
<li>AbstractAutowireCapableBeanFactory：继承了AbstractBeanFactory，实现了AutowireCapableBeanFactory，拥有了自动装配的功能</li>
<li>DefaultListableBeanFactory：继承了AbstractAutowireCapableBeanFactory，实现了ConfigurableListableBeanFactory接口和BeanDefinitionRegistry接口，所以DefaultListableBeanFactory的功能很强大</li>
</ol>
<p>DefaultListableBeanFactory支持的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">beanDefinition.setBeanClass(User.class);</span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册BeanDefinition</span></span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">&quot;user&quot;</span>, beanDefinition);</span><br><span class="line"><span class="comment">// 注册别名</span></span><br><span class="line">beanFactory.registerAlias(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;user1&quot;</span>);</span><br><span class="line"><span class="comment">// 注册BeanPostProcessor</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> DemoBeanPostProcessor());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Bean对象</span></span><br><span class="line">System.out.println(beanFactory.getBean(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line"><span class="comment">// 根据类型获取beanNames</span></span><br><span class="line">System.out.println(beanFactory.getBeanNamesForType(User.class));</span><br></pre></td></tr></table></figure>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>首先ApplicationContext是个接口，可以把它理解为一个特殊的BeanFactory</p>
<p><img src="/2021/03/22/Spring%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/application-context.png" alt="application-context"></p>
<ol>
<li>HierarchicalBeanFactory：拥有获取父BeanFactory的功能</li>
<li>ListableBeanFactory：拥有获取beanNames的功能</li>
<li>ResourcePatternResolver：资源加载器，可以一次性获取多个资源（文件资源等等）</li>
<li>EnvironmentCapable：可以获取运行时环境（没有设置运行时环境功能）</li>
<li>ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能）</li>
<li>MessageSource：拥有国际化功能</li>
</ol>
<h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><p><img src="/2021/03/22/Spring%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/annotation-config-application-context.png" alt="annotation-config-application-context"></p>
<ol>
<li>ConfigurableApplicationContext：继承了ApplicationContext接口，增加了，添加事件监听器、添加BeanFactoryPostProcessor、设置Environment，获取ConfigurableListableBeanFactory等功能</li>
<li>AbstractApplicationContext：实现了ConfigurableApplicationContext接口</li>
<li>GenericApplicationContext：继承了AbstractApplicationContext，实现了BeanDefinitionRegistry接口，拥有了所有ApplicationContext的功能，并且可以注册BeanDefinition，注意这个类中有一个属性(DefaultListableBeanFactory <strong>beanFactory</strong>)</li>
<li>AnnotationConfigRegistry：可以单独注册某个为类为BeanDefinition（可以处理该类上的**@Configuration注解<strong>，已经可以处理</strong>@Bean注解**），同时可以扫描</li>
<li>AnnotationConfigApplicationContext：继承了GenericApplicationContext，实现了AnnotationConfigRegistry接口，拥有了以上所有的功能</li>
</ol>
<h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h3><p><img src="/2021/03/22/Spring%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/xml-web-application-context.png" alt="xml-web-application-context"></p>
<p>它也是继承了AbstractApplicationContext，但是相对于AnnotationConfigApplicationContext而言，功能没有AnnotationConfigApplicationContext强大，比如不能注册BeanDefinition</p>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>先定义一个MessageSource:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">    messageSource.setBasename(<span class="string">&quot;messages&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个Bean，你可以在你任意想要进行国际化的地方使用该MessageSource。</p>
<p>同时，因为ApplicationContext也拥有国家化的功能，所以可以直接这么用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">annotationConfigApplicationContext.getMessage(<span class="string">&quot;test&quot;</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Locale(<span class="string">&quot;en_CN&quot;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>ApplicationContext还拥有资源加载的功能，比如，可以直接利用ApplicationContext获取某个文件的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource resource = annotationConfigApplicationContext.getResource(<span class="string">&quot;file://D:\\IdeaProjects\\spring-framework\\demo\\src\\main\\java\\com\\demo\\entity\\User.java&quot;</span>);</span><br><span class="line">System.out.println(resource.contentLength());</span><br></pre></td></tr></table></figure>
<p>你可以想想，如果你不使用ApplicationContext，而是自己来实现这个功能，就比较费时间了。</p>
<p>还比如你可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource resource = annotationConfigApplicationContext.getResource(<span class="string">&quot;classpath:com/demo/entity/User.class&quot;</span>);</span><br><span class="line">System.out.println(resource.contentLength());</span><br></pre></td></tr></table></figure>


<p>还可以一次性获取多个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource[] resources=annotationConfgigApplicationContext.getResources(<span class="string">&quot;classpath:com/demo/service/*.class&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System.out.println(resource.contentLength());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="获取运行时环境"><a href="#获取运行时环境" class="headerlink" title="获取运行时环境"></a>获取运行时环境</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取JVM所允许的操作系统的环境</span></span><br><span class="line">annotationConfigApplicationContext.getEnvironment().getSystemEnvironment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取JVM本身的一些属性，包括-D所设置的</span></span><br><span class="line">annotationConfigApplicationContext.getEnvironment().getSystemProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以直接获取某个环境或properties文件中的属性</span></span><br><span class="line">annotationConfigApplicationContext.getEnvironment().getProperty(<span class="string">&quot;testyyy&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注意，可以利用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br></pre></td></tr></table></figure>
<p>来使得某个properties文件中的参数添加到运行时环境中</p>
<h3 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h3><p>先定义一个事件监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationListener <span class="title">applicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到了一个事件&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后发布一个事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">annotationConfigApplicationContext.publishEvent(<span class="string">&quot;kkk&quot;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><h3 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a>PropertyEditor</h3><p>JDK中提供的类型转化工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserPropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> <span class="keyword">implements</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(text);</span><br><span class="line">        <span class="keyword">this</span>.setValue(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringToUserPropertyEditor propertyEditor = <span class="keyword">new</span> StringToUserPropertyEditor();</span><br><span class="line">propertyEditor.setAsText(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">User value = (User) propertyEditor.getValue();</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>


<p>如何向Spring中注册PropertyEditor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomEditorConfigurer <span class="title">customEditorConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CustomEditorConfigurer customEditorConfigurer = <span class="keyword">new</span> CustomEditorConfigurer();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; propertyEditorMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    propertyEditorMap.put(User.class, StringToUserPropertyEditor.class);</span><br><span class="line">    customEditorConfigurer.setCustomEditors(propertyEditorMap);</span><br><span class="line">    <span class="keyword">return</span> customEditorConfigurer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>假设现在有如下Bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;true&quot;)</span></span><br><span class="line">    User test;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么test属性就能正常的完成属性赋值</p>
<h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>Spring中提供的类型转化服务，它比PropertyEditor更强大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sourceType.getType().equals(String.class) &amp;&amp; targetType.getType().equals(User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(String.class, User.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName((String)source);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">conversionService.addConverter(<span class="keyword">new</span> StringToUserConverter());</span><br><span class="line">User value = conversionService.convert(<span class="string">&quot;1&quot;</span>, User.class);</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>


<p>如何向Spring中注册ConversionService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">    conversionServiceFactoryBean.setConverters(Collections.singleton(<span class="keyword">new</span> StringToUserConverter()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conversionServiceFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="TypeConverter"><a href="#TypeConverter" class="headerlink" title="TypeConverter"></a>TypeConverter</h3><p>整合了PropertyEditor和ConversionService的功能，是Spring内部用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleTypeConverter typeConverter = <span class="keyword">new</span> SimpleTypeConverter();</span><br><span class="line">typeConverter.registerCustomEditor(User.class, <span class="keyword">new</span> StringToUserPropertyEditor());</span><br><span class="line"><span class="comment">//typeConverter.setConversionService(conversionService);</span></span><br><span class="line">User value = typeConverter.convertIfNecessary(<span class="string">&quot;1&quot;</span>, User.class);</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>


<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>Bean的后置处理器，可以在创建每个Bean的过程中进行干涉，是属于BeanFactory中一个属性，讲Bean的生命周期中详细讲。</p>
<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>Bean工厂的后置处理器，是属于ApplicationContext中的一个属性，是ApplicationContext在实例化一个BeanFactory后，可以利用BeanFactoryPostProcessor继续处理BeanFactory。</p>
<p>程序员可以通过BeanFactoryPostProcessor间接的设置BeanFactory，比如上文中的CustomEditorConfigurer就是一个BeanFactoryPostProcessor，我们可以通过它向BeanFactory中添加自定义的PropertyEditor。</p>
<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>允许程序员自定义一个对象通过FactoryBean间接的放到Spring容器中成为一个Bean。</p>
<p>那么它和@Bean的区别是什么？因为@Bean也可以自定义一个对象，让这个对象成为一个Bean。</p>
<p>区别在于利用FactoryBean可以更加强大，因为你通过定义一个XxFactoryBean的类，可以再去实现Spring中的其他接口，比如如果你实现了BeanFactoryAware接口，那么你可以在你的XxFactoryBean中获取到Bean工厂，从而使用Bean工厂做更多你想做的，而@Bean则不行。</p>
<h2 id="Spring中的“父子”"><a href="#Spring中的“父子”" class="headerlink" title="Spring中的“父子”"></a>Spring中的“父子”</h2><ol>
<li>父子类</li>
<li>父子BeanDefinition</li>
<li>父子BeanFactory</li>
<li>父子ApplicationContext</li>
</ol>
<h3 id="父子类"><a href="#父子类" class="headerlink" title="父子类"></a>父子类</h3><p>父子类是Java中的概念，在Spring中，当给某个类创建Bean的过程中，Spring不仅仅会对本类中的属性进行自动注入，同时也会对父类的属性进行自动注入。</p>
<h3 id="父子BeanDefinition"><a href="#父子BeanDefinition" class="headerlink" title="父子BeanDefinition"></a>父子BeanDefinition</h3><p>父子BeanDefinition是Spring中的概念，Spring在根据BeanDefinition创建Bean的过程中，会先看当前BeanDefinition是否存在父BeanDefinition，如果存在则需要进行合并，合并就是把子BeanDefinition和父BeanDefinition中所定义的属性整合起来（如果存在某个属性在父子BeanDefinition中都存在，那么取子BeanDefinition中的属性）</p>
<h3 id="父子BeanFactory"><a href="#父子BeanFactory" class="headerlink" title="父子BeanFactory"></a>父子BeanFactory</h3><p>BeanFactory是一个Bean的容器，在Spring中，当我们在使用某个BeanFactory去获取Bean时，如果本BeanFactory中不存在该Bean，同时又有父BeanFactory，那么则会检查父BeanFactory是否存在该Bean，如果也不存在，那么则会创建Bean</p>
<h3 id="父子ApplicationContext"><a href="#父子ApplicationContext" class="headerlink" title="父子ApplicationContext"></a>父子ApplicationContext</h3><p>父子ApplicationContext和父子BeanFactory类似，子ApplicationContext除开可以使用父ApplicationContext来获取Bean之外，还可以使用父ApplicationContext中其他的东西，比如ApplicationListener</p>
]]></content>
      <categories>
        <category>框架源码</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring推断构造方法</title>
    <url>/2021/07/19/Spring%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Spring中的一个bwan，需要实例化得到一个对象，而实例化就需要用到构造方法</p>
<h2 id="类只有一个构建方法"><a href="#类只有一个构建方法" class="headerlink" title="类只有一个构建方法"></a>类只有一个构建方法</h2><ol>
<li><p>无参的构造方法</p>
<p>如果只有一个无参的构造方法，那么实例化就只能使用这个方法</p>
</li>
<li><p>有参的构造方法</p>
<p>如果只有一个有参的构造方法，那么实例化时就能使用这个构造方法吗？也是需要分情况讨论的</p>
<ol>
<li>使用AnnotationConfigApplicationContext，会使用这个构造方法进行实例化，那么Spring会根据构造方法的参数信息去寻找bean，然后传给构造方法</li>
<li>使用ClassPathXmlApplicationContext，表示使用XML的方式来使用bean，要么在XML中指定构造方法参数值（手动设置），要不配置autowired=constructor让spring自动寻找bean作为构造方法的参数</li>
</ol>
</li>
</ol>
<a id="more"></a>

<h2 id="类有多个构造方法"><a href="#类有多个构造方法" class="headerlink" title="类有多个构造方法"></a>类有多个构造方法</h2><ol>
<li>如果开发者指定了想要使用的构造方法,那么使用这个构建方法</li>
<li>如果开发者没有指定想要使用的构造方法,那么就看开发者是不是让Spring自动选择构造方法</li>
<li>如果没有让Spring自动去选择构造方法，则Spring利用无参构造方法，如果没有无参构造方法则报错</li>
</ol>
<h3 id="指定使用构造方法"><a href="#指定使用构造方法" class="headerlink" title="指定使用构造方法"></a>指定使用构造方法</h3><ol>
<li>XML中的<constructor-arg>标签，这个标签表示构造方法参数，所以可以根据这个确定想要使用的构造方法的参数个数，从而确定想要使用的构造方法</constructor-arg></li>
<li>通过@Autowired注解，注解可以写在构造方法上，标注了注解的构造方法就是开发者指定的构造方法。两者的区别在与通过xml的方式是通过直接指定构造方法参数值的，而通过@Autowired注解则需要通过Spring先byType再byName的方式找到符合条件的bean作为构造方法的入参</li>
<li>如果多个构造方法上都写了@Autowired(required=true)，Spring要求只存在一个@Autowired或@Autowired(required=true)的构造方法，多个会报错</li>
</ol>
<h3 id="Spring自动选择构造方法"><a href="#Spring自动选择构造方法" class="headerlink" title="Spring自动选择构造方法"></a>Spring自动选择构造方法</h3><ol>
<li>使用ClassPathXmlApplicationContext，XML中直接指定某个bean的autowire为constructor</li>
<li>使用AnnotationConfigApplicationContext，无法设置bean自动选择构造器</li>
<li>Spring允许多个@Autowired(required=false)，这种情况下Spring会从这些构造方法中自动寻找一个</li>
</ol>
<h2 id="源码思路"><a href="#源码思路" class="headerlink" title="源码思路"></a>源码思路</h2><ol>
<li>AbstractAutowireCapableBeanFactory类中的createBeanInstance()方法会去创建一个Bean实例</li>
<li>根据BeanDefinition加载类得到Class对象</li>
<li>如果BeanDefinition绑定了一个instanceSupplier,那么调用instanceSupplier的get方法得到一个对象并返回</li>
<li>如果BeanDefinition中存在<strong>factoryMethodName</strong>，那么就调用该工厂方法得到一个bean对象并返回</li>
<li>如果BeanDefinition已经自动构建过了，那么就调用autowireConstructor()自动构建一个对象</li>
<li>调用SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors()方法得到哪些构造方法是可以用的</li>
<li>如果上一步返回了构造方法，或者当前BeanDefinition的autowireMode属性是AUTOWIRE_CONSTRUCTOR，或者创建Bean时指定了构造方法参数值，那么就调用autowireConstructor()方法自动构造一个对象</li>
<li>最后，如果不是上述情况，就根据无参构造方法实例化一个对象</li>
</ol>
<h3 id="autowireConstructor"><a href="#autowireConstructor" class="headerlink" title="autowireConstructor()"></a>autowireConstructor()</h3><ol>
<li>先检查是否指定了具体的构造方法和构造方法参数值，或者在BeanDefinition中缓存了具体的构造方法或者构造方法参数值，如果存在那么直接使用该构造方法进行实例化</li>
<li>如果没有确定的构造方法或者构造方法参数值<ol>
<li>如果没有确定的构造方法，那么则找出类中所有的构造方法</li>
<li>如果只有一个无参的构造方法，那么直接使用无参的构造方法进行实例化</li>
<li>如果有多个可用的构造方法或者当前Bean需要通过构造方法注入<ol>
<li>根据所指定的的构造方法参数值，确定所需要最少的构造方法参数值个数</li>
<li>对所有的构造方法进行排序，参数个数多的放在前面（贪婪）</li>
<li>遍历所有的构造方法，如果不是调用bean方法时所指定的构造方法参数值，那么根据构造方法参数类型找值，如果是制定的构造方法参数值，那么直接利用这些值，如果根据当前构造方法找到了构造方法参数值，那么这个构造方法就是可用的，但是不一定是最佳的，所以这里会有涉及到多个构造方法匹配到了值，会用值和构造方法参数类型进行匹配程度打分，找到一个最匹配的</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="匹配程度计算"><a href="#匹配程度计算" class="headerlink" title="匹配程度计算"></a>匹配程度计算</h4><p>主要是计算找到的bean和构造方法参数类型匹配程度有多高。</p>
<p>假设bean的类型为A，A的父类是B，B的父类是C，同时A实现了接口D</p>
<p>如果构造方法的参数类型为A，那么完全匹配，得分为0</p>
<p>如果构造方法的参数类型为B，那么得分为2</p>
<p>如果构造方法的参数类型为C，那么得分为4</p>
<p>如果构造方法的参数类型为D，那么得分为1</p>
<p>可以直接使用如下代码进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] objects = <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> A()&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="keyword">new</span> Class[]&#123;A.class&#125;, objects));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="keyword">new</span> Class[]&#123;B.class&#125;, objects));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="keyword">new</span> Class[]&#123;C.class&#125;, objects));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="keyword">new</span> Class[]&#123;D.class&#125;, objects));</span><br></pre></td></tr></table></figure>
<p>所以，我们可以发现，越匹配分数越低。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/2021/07/19/Spring%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/autowireConstructor.jpg" alt="autowireConstructor"></p>
<h3 id="determineCandidateConstructors"><a href="#determineCandidateConstructors" class="headerlink" title="determineCandidateConstructors()"></a>determineCandidateConstructors()</h3><p><img src="/2021/07/19/Spring%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/determineCandidateConstructors.jpg" alt="determineCandidateConstructors"></p>
]]></content>
      <categories>
        <category>框架源码</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring依赖注入源码</title>
    <url>/2021/06/16/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>上节讲了Spring中的自动注入(byName,byType)和@Autowired注解的工作原理以及源码分析，这一节我们来分析剩下的核心的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String requestingBeanName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure>
<p>该方法表示，传入一个依赖描述（DependencyDescriptor），该方法会根据该依赖描述从BeanFactory中找出对应的唯一的一个Bean对象。</p>
<a id="more"></a>

<p>下面来分析一下<strong>DefaultListableBeanFactory</strong>中**resolveDependency()**方法的具体实现。</p>
<p><img src="/2021/06/16/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%BA%90%E7%A0%81/resolveDependency%E6%B5%81%E7%A8%8B.jpg" alt="resolveDependency流程"></p>
<h2 id="findAutowireCandidates-实现"><a href="#findAutowireCandidates-实现" class="headerlink" title="findAutowireCandidates()实现"></a>findAutowireCandidates()实现</h2><ol>
<li>找出BeanFactory中类型为type的所有的Bean的名字，注意是名字，而不是Bean对象，因为我们可以根据BeanDefinition就能判断和当前type是不是匹配</li>
<li>把resolvableDependencies中key为type的对象找出来并添加到result中</li>
<li>遍历根据type找出的beanName，判断当前beanName对应的Bean是不是能够被自动注入</li>
<li>先判断beanName对应的BeanDefinition中的autowireCandidate属性，如果为false，表示不能用来进行自动注入，如果为true则继续进行判断</li>
<li>判断当前type是不是泛型，如果是泛型是会把容器中所有的beanName找出来的，如果是这种情况，那么在这一步中就要获取到泛型的真正类型，然后进行匹配，如果当前beanName和当前泛型对应的真实类型匹配，那么则继续判断</li>
<li>如果当前DependencyDescriptor上存在@Qualifier注解，那么则要判断当前beanName上是否定义了Qualifier，并且是否和当前DependencyDescriptor上的Qualifier相等，相等则匹配</li>
<li>经过上述验证之后，当前beanName才能成为一个可注入的，添加到result中</li>
</ol>
]]></content>
      <categories>
        <category>框架源码</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring解析配置类以及扫描源码解析</title>
    <url>/2021/07/12/Spring%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BB%A5%E5%8F%8A%E6%89%AB%E6%8F%8F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="执行BeanFactoryPostProcessor"><a href="#执行BeanFactoryPostProcessor" class="headerlink" title="执行BeanFactoryPostProcessor"></a>执行BeanFactoryPostProcessor</h2><ol>
<li>执行通过ApplicationContext添加进来的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
<li>执行BeanFactory中实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
<li>执行BeanFactory中实现了Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
<li>执行BeanFactory中其他的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
<li>执行上面所有的BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法</li>
<li>执行通过ApplicationContext添加进来的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li>
<li>执行BeanFactory中实现了PriorityOrdered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li>
<li>执行BeanFactory中实现了Ordered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li>
<li>执行BeanFactory中其他的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li>
</ol>
<a id="more"></a>

<h2 id="ConfigurationClassPostProcessor执行流程"><a href="#ConfigurationClassPostProcessor执行流程" class="headerlink" title="ConfigurationClassPostProcessor执行流程"></a>ConfigurationClassPostProcessor执行流程</h2><p><img src="/2021/07/12/Spring%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BB%A5%E5%8F%8A%E6%89%AB%E6%8F%8F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/ConfigurationBeanPostProsessor.jpg" alt="ConfigurationBeanPostProsessor"></p>
<ol>
<li>启动Spring时，需要传入一个AppConfig.class给ApplicationContext，ApplicationContext会根据AppConfig类封装成一个BeanDefinition，这种BeanDefinition我们把它称为配置类BeanDefinition。</li>
<li>ConfigurationClassClassProcessor中会把配置类BeanDefinition取出来</li>
<li>构建一个ConfigurationClassParser用来解析配置类BeanDefinition，并且会生成一个配置类对象ConfigurationClass</li>
<li>如果配置类中存在@Component注解，那么解析配置类中的内部类（如果内部类也是配置类，会递归）</li>
<li>如果配置类上存在@PropertySource注解，那么则解析该注解，并得到PropertySource对象，并添加到environment中去</li>
<li>如果配置类上存在@ConponentScan注解，那么解析改注解，进行扫描，得到BeanDefinition集合，然后判断这些BeanDefinition是不是也是配置类（只要存在@Component注解的就是配置类，所以扫描出来的基本都是配置类），如果是配置类则继续解析该配置类（递归），并且会生成对应的ConfigurationClass</li>
<li>如果配置类上存在@Import注解，那么判断import进来的类的类型：<ol>
<li>如果类型是ImportSelector，那么调用执行selectImports方法的到类名，然后把这个类当做配置类进行解析（递归）</li>
<li>如果类型是ImportBeanDefinitionRegistrar，那么则生成一个ImportBeanDefinitionRegistrar实例对象，并添加到配置类中的importBeanDefinitionRegistrars属性中</li>
<li>否则继续解析该配置类（递归）</li>
</ol>
</li>
<li>如果配置类存在@ImporResource注解，那么则把导入进来的资源路径存在配置类对象中的importedResources属性中</li>
<li>如果配置类上存在@Bean的方法，那么则把这些方法封装为BeanMethod对象，并添加到配置类对象中的beanMethod属性中</li>
<li>如果配置类实现了某些接口，看这些接口内是否定义了@Bean的默认方法</li>
<li>如果配置类有父类，则把父类当做配置类解析</li>
<li>AppConfig这个类会对应一个ConfigurationClass，同时在解析的过程中也会生成另外的一些ConfigurationClass，接下来就利用reader来进一步解析ConfigurationClass<ol>
<li>如果ConfigurationClass是通过@Import注解导入进来的，则把这个类生成一个BeanDefinition，同时解析这个类上@Scope,@Lazy等注解信息，并注册BeanDefinition</li>
<li>如果ConfigurationClass中存在一些BeanMethod,也就是定义了@Bean，那么则解析这些@Bean，并生成对应的BeanDefinition，并注册</li>
<li>如果ConfigurationClass中导入了一些资源文件，比如xx.xml，那么则解析这些xx.xml文件，得到并注册BeanDefinition</li>
<li>如果ConfigurationClass中导入了一些ImportBeanDefinitionRegistrar，那么则执行对应的registerBeanDefinitions进行BeanDefinition的注册</li>
</ol>
</li>
</ol>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ol>
<li>解析Appconfig类，并生成对应的ConfigurationClass</li>
<li>扫描得到对应的BeanDefinition，同时这些类也是ConfigurationClass，再次解析</li>
<li>解析ConfigurationClass的其他信息，例如@Import注解等</li>
</ol>
]]></content>
      <categories>
        <category>框架源码</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>理解IO模型与多路复用</title>
    <url>/2021/01/19/%E7%90%86%E8%A7%A3IO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>IO模型就是说用什么样的通道进行数据的发送和接收，Java支持3种网络编程IO模式：<strong>BIO,NIO,AIO</strong></p>
<a id="more"></a>

<h4 id="BIO-Blocking-IO"><a href="#BIO-Blocking-IO" class="headerlink" title="BIO(Blocking IO)"></a>BIO(Blocking IO)</h4><p>同步阻塞。同步就是上一个步骤没有完成，就不能进行下一个步骤。阻塞就是必须等待一个步骤处理完，并得到结果。对于单线程的网络服务，这样做就会有卡死的问题，因为当等待时，整个线程会被挂起，无法执行，也无法做其他的工作。于是，网络服务为了同时响应多个并发的网络请求，必须实现为多线程的。每个线程处理一个网络请求。</p>
<p><strong>应用场景：</strong></p>
<p>连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 但程序简单易理解。</p>
<p><img src="/2021/01/19/%E7%90%86%E8%A7%A3IO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/bio.png" alt="bio"></p>
<p><strong>缺点：</strong></p>
<ul>
<li><p>线程越多，线程的上下文切换越多，而线程的上下文切换时一个耗时的操作，会浪费大量的CPU。</p>
</li>
<li><p>每个线程会占用一定的内存作为线程的栈，连接线程很多会导致服务器线程太多，压力太大，比如C10K问题</p>
</li>
<li><p>IO代码里read操作是阻塞操作，如果连接不做数据读写操作会导致线程阻塞，浪费资源</p>
</li>
</ul>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接&quot;</span>);</span><br><span class="line">            <span class="comment">//阻塞方法</span></span><br><span class="line">            Socket clientSocket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;有新的客户端连接&quot;</span>);</span><br><span class="line">            handler(clientSocket);</span><br><span class="line">            <span class="comment">//使用多线程处理客户端请求</span></span><br><span class="line"><span class="comment">//            new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//                @Override</span></span><br><span class="line"><span class="comment">//                public void run() &#123;</span></span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line"><span class="comment">//                        handler(clientSocket);</span></span><br><span class="line"><span class="comment">//                    &#125;catch (IOException e)&#123;</span></span><br><span class="line"><span class="comment">//                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;).start();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket clientSocket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;准备read...&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read = clientSocket.getInputStream().read(bytes);</span><br><span class="line">        <span class="keyword">if</span>(read != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到客户端的数据：&quot;</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));</span><br><span class="line">        &#125;</span><br><span class="line">        clientSocket.getOutputStream().write(<span class="string">&quot;HelloClient&quot;</span>.getBytes());</span><br><span class="line">        clientSocket.getOutputStream().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket clientSocket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        clientSocket.getOutputStream().write(<span class="string">&quot;HelloServer&quot;</span>.getBytes());</span><br><span class="line">        clientSocket.getOutputStream().flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;向服务端发送数据结束&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//接收服务端的回传数据</span></span><br><span class="line">        <span class="keyword">int</span> read = clientSocket.getInputStream().read(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到服务端的数据:&quot;</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));</span><br><span class="line">        clientSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NIO-Non-Blocking-IO"><a href="#NIO-Non-Blocking-IO" class="headerlink" title="NIO(Non Blocking IO)"></a>NIO(Non Blocking IO)</h4><p>同步非阻塞，服务器实现模式为<strong>一个线程可以处理多个请求(连接)**，客户端发送的连接请求都会注册到</strong>多路复用器selector**上，多路复用器轮询到连接有IO请求就进行处理，JDK1.4开始引入。</p>
<p><strong>应用场景：</strong></p>
<p>NIO方式适用于连接数目多且连接比较短（轻操作） 的架构， 比如聊天服务器， 弹幕系统， 服务器间通讯，编程比较复杂。</p>
<p><img src="/2021/01/19/%E7%90%86%E8%A7%A3IO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/nio.png" alt="NIO"></p>
<p>NIO非阻塞代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建NIO ServerSocketChannel 类似 BIO中的 ServerSocket</span></span><br><span class="line">        ServerSocketChannel serverSocket = ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">//设置 ServerSocketChannel 为非阻塞</span></span><br><span class="line">        serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功&quot;</span>);</span><br><span class="line">        List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//非阻塞模式 accept不会阻塞，否则会阻塞</span></span><br><span class="line">            <span class="comment">//NIO的非阻塞是由操作系统实现的，底层调用了linux的accept函数</span></span><br><span class="line">            SocketChannel socketChannel = serverSocket.accept();</span><br><span class="line">            <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//设置ServerSocketChannel为非阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                channelList.add(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            Iterator&lt;SocketChannel&gt; iterator = channelList.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SocketChannel sc = iterator.next();</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                <span class="keyword">int</span> len = sc.read(byteBuffer);</span><br><span class="line">                <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + <span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>,len));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果客户端断开，把socket从集合中去掉</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：如果连接数太多的话，会有大量的无效遍历，假如有10000个连接，其中只有1000个连接有写数据，但是由于其他9000个连接并没有断开，我们还是要每次轮询遍历一万次，其中有十分之九的遍历都是无效的，这显然不是一个让人很满意的状态。</p>
<p>NIO多路复用代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSelectorServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建NIO ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocket = ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span></span><br><span class="line">        serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待需要处理的事件发生</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 获取selector中注册的全部事件的 SelectionKey 实例</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 遍历SelectionKey对事件进行处理</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel socketChannel = server.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 这里只注册了读事件，如果需要给客户端发送数据可以注册写事件</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                    <span class="keyword">int</span> len = socketChannel.read(byteBuffer);</span><br><span class="line">                    <span class="comment">// 如果有数据，把数据打印出来</span></span><br><span class="line">                    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + <span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>, len));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果客户端断开连接，关闭Socket</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从事件集合里删除本次处理的key，防止下次select重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>NIO主要有三大核心部分：Channel（通道）。Buffer（缓冲区）、Selector。</strong></p>
<ul>
<li>Channel：通道，和IO中的Stream流是差不多一个等级的，只不过Stream是单向的，譬如：InputStream，OutputStream，而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作,每个 channel 对应一个 buffer缓冲区。</li>
<li>Buffer：缓冲区，实际上是一个字节数组，NIO中，所有数据都是用缓冲区处理的，任何时候访问NIO中的数据，都是将它放到缓冲区中，既可以读也可以写。</li>
<li>Selector：多路复用器，可以将通道注册进选择器中，其重要作用就是使用一个线程来对多个通道中的已就绪通道进行选择，然后就可以对选择的通道进行数据处理，属于一对多的关系，这种机制就叫IO多路复用。</li>
</ul>
<blockquote>
<p>文件描述符：<strong>Linux的内核将所有外部设备都看做一个文件来操作</strong>，<strong>对一个文件的读写操作会调用内核提供的系统命令</strong>（api），返回一个file descriptor（fd，文件描述符）。而对一个socket的读写也会有相应的描述符，称为socket fd（socket文件描述符），**描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）。所以说：在Linux下对文件的操作是利用文件描述来符实现的。</p>
</blockquote>
<h4 id="AIO-NIO-2-0"><a href="#AIO-NIO-2-0" class="headerlink" title="AIO(NIO 2.0)"></a>AIO(NIO 2.0)</h4><p><strong>异步非阻塞， 由操作系统完成后回调通知服务端程序启动线程去处理， 一般适用于连接数较多且连接时间较长的应用</strong></p>
<p><strong>应用场景：</strong></p>
<p>AIO方式适用于连接数目多且连接比较长(重操作)的架构，JDK7 开始支持</p>
<p>AIO代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel</span><br><span class="line">          .open().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2--&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="comment">//再次接收客户端连接，如果不写会导致后面的客户端连不上服务端</span></span><br><span class="line">                    serverChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;3--&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloClient&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            exc.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;1--&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AsynchronousSocketChannel socketChannel = AsynchronousSocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>)).get();</span><br><span class="line">        socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloServer&quot;</span>.getBytes()));</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        Integer len = socketChannel.read(buffer).get();</span><br><span class="line">        <span class="keyword">if</span>(len != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端收到信息&quot;</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BIO、-NIO、-AIO-对比："><a href="#BIO、-NIO、-AIO-对比：" class="headerlink" title="BIO、 NIO、 AIO 对比："></a>BIO、 NIO、 AIO 对比：</h4><p><img src="/2021/01/19/%E7%90%86%E8%A7%A3IO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/diff.png" alt="diff"></p>
<h4 id="为什么Netty使用NIO而不是AIO？"><a href="#为什么Netty使用NIO而不是AIO？" class="headerlink" title="为什么Netty使用NIO而不是AIO？"></a>为什么Netty使用NIO而不是AIO？</h4><p>在Linux系统上，AIO的底层实现仍使用Epoll，没有很好实现AIO，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化，Linux上AIO还不够成熟。Netty是<strong>异步非阻塞</strong>框架，Netty在NIO上做了很多异步的封装。</p>
<h3 id="IO多路复用（Linux）"><a href="#IO多路复用（Linux）" class="headerlink" title="IO多路复用（Linux）"></a>IO多路复用（Linux）</h3><p>IO多路复用是一个线程通过一个select就可以检查多个文件描述符，它们能够同时检查多个文件描述符，看这些文件描述符是否处于就绪状态（对文件的IO系统调用能否非阻塞的执行）。文件描述符就绪状态的转换是通过一些I/O事件来触发的， 比如输入数据到达，套接字把连接建立完成，或者是之前满载的套接字发送缓冲区在TCP将队列中的数据传送到对端之后有了剩余空间。事件轮询API在Jdk中包装后就是NIO，但是多路复用不是Java特有的，其他语言中他们不叫NIO而已。</p>
<p>NIO底层在JDK1.4版本是用linux的内核函数select()或poll()来实现，JDK1.5开始引入了epoll基于事件响应机制来优化NIO。接下来是Linux中事件轮询API。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>系统调用selet()会一直阻塞，所以从操作系统角度上看，select也是同步阻塞的，包括poll/epoll都是如此，直到一个或多个文件描述符集合成为就绪状态。在select中提供了三个集合<strong>readfds、writefds、exceptfds</strong>，分别代表的是<strong>输入就绪、输出就绪、异常发生</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>; </span><br></pre></td></tr></table></figure>
<p>输入是读写描述符列表readfds和write_fds，输出是与之对应的事件。</p>
<p><strong>存在的问题</strong></p>
<ol>
<li>每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，这个开销也很大</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，这个开销也很大</li>
<li>为了减少数据拷贝带来的性能损坏，内核对监控的fd_set集合大小做了限制（默认为1024）</li>
</ol>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>系统调用poll()执行的任务通select()很相似，两者的区别主要在于我们如何指定文件描述符。在select中，我们需要提供三个集合，每个集合表明我们感兴趣的文件描述符，而在 poll()中提供一列文件描述符，并在每个文件描述符上标明我们感兴趣的事件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fds[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"> <span class="keyword">int</span> fd;               <span class="comment">// 文件描述符</span></span><br><span class="line"> <span class="keyword">short</span> events;        <span class="comment">// 调用者指定该文件描述符感兴趣的事件</span></span><br><span class="line"> <span class="keyword">short</span> revents;      <span class="comment">// 该文件描述符上实际发生的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll和select机制是类似的，本质没有什么区别，相对于select来讲，epoll是没有描述符个数限制的，也就是说poll只解决了select第三个问题，并没有解决性能开销问题。</p>
<h4 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个epoll实例，并返回一个非负数作为文件描述符，用于对epoll接口的所有后续调用。参数size代表可能会容纳size个描述符，但size不是一个最大值，只是提示操作系统它的数量级，现在这个参数基本上已经弃用了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;    </span><br></pre></td></tr></table></figure>
<p>使用文件描述符epfd引用的epoll实例，对目标文件描述符fd执行op操作。</p>
<p>参数epfd表示epoll对应的文件描述符，参数fd表示socket对应的文件描述符。</p>
<p>参数op有以下几个值：</p>
<p>EPOLL_CTL_ADD：注册新的fd到epfd中，并关联事件event；</p>
<p>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</p>
<p>EPOLL_CTL_DEL：从epfd中移除fd，并且忽略掉绑定的event，这时event可以为null；          </p>
<p>使用文件描述符epfd引用的epoll实例，对目标文件描述符fd执行op操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;                              </span><br></pre></td></tr></table></figure>
<p>函数等待文件描述符epfd上的事件的就绪，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0</p>
<p>epfd是Epoll对应的文件描述符，events表示调用者所有可用事件的集合，maxevents表示最多等到多少个事件就返回，timeout是超时时间。</p>
<p><strong>Epoll基于事件驱动的 I/O 方式</strong>，相对于 select 来说，epoll 没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次，解决了之前函数的缺陷：</p>
<ul>
<li>涉及到fd数组在用户空间到内核空间数据拷贝的过程</li>
<li>select和poll函数返回值只能代表有几个socket就绪，没法表示具体是哪个socket就绪，这就需要重新遍历fd数组去检查那个socket是就绪的</li>
</ul>
<h4 id="事件轮询API对比"><a href="#事件轮询API对比" class="headerlink" title="事件轮询API对比"></a>事件轮询API对比</h4><table>
<thead>
<tr>
<th></th>
<th><strong>select</strong></th>
<th><strong>poll</strong></th>
<th><strong>epoll(jdk 1.5及以上)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>操作方式</strong></td>
<td>遍历</td>
<td>遍历</td>
<td>回调</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>数组</td>
<td>链表</td>
<td>哈希表</td>
</tr>
<tr>
<td><strong>IO效率</strong></td>
<td>每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td>每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td>事件通知方式，每当有IO事件就绪，系统注册的回调函数就会被调用，时间复杂度O(1)</td>
</tr>
<tr>
<td><strong>最大连接</strong></td>
<td>有上限</td>
<td>无上限</td>
<td>无上限</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>分布式框架</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>IO</tag>
        <tag>BIO</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
</search>
